# 이진 트리

- 모든 노드들이 **2개의 서브트리**를 갖는 특별한 형태의 트리

- 각 노드가 자식 노드를 **최대 2개** 까지만 가질 수 있는 트리

    - 왼쪽 자식 노드, 오른쪽 자식 노드

## 이진트리의 특성

- 레벨 i 에서 노드의 최대 개수는 2^i개

- 높이가 h인 이진 트리가 가질 수 있는 노드의 **최소 개수는 h + 1개**가 되며, **최대 개수는 2^(h + 1) - 1개**가 된다.

## 이진트리의 종류

> 이진 트리의 종류에 따라, 접근 방법, 저장 방식이 달라진다.

### 포화 이진 트리(Full Binary Tree)

- 모든 레벨의 모든 노드가 포화상태로 차 있는 이진 트리

- **2^(h+1) - 1 개의 노드**를 가진 이진 트리(높이가 h일 때, 이진 트리의 최대 노드 개수)

- **루트를 1번으로 하여 2^(h+1) - 1 까지 정해진 위치에 대한 노드 번호를 가짐**

### 완전 이진 트리(Complete Binary Tree)

- 높이가 h이고 노드 수가 n개일 때(단, h + 1 <= n < 2^(h + 1) - 1), 포화 이진 트리의 **노드 1번부터 n번까지 빈 자리가 없는** 이진 트리

- 중간에서 빠진게 없는 트리. 1에서 n번까지는 다 있어야 함.

### 편향 이진 트리(Skewed Binary Tree)

- 높이 h에 대한 최소 개수의 노드를 가지면서 한쪽 방향의 자식 노드만을 가진 이진 트리

    - 왼쪽 편향 이진 트리

    - 오른쪽 편향 이진 트리

- 선형 자료 구조처럼 만들어진 경우

## 이진트리의 순회

- 순회(traversal)란 트리의 각 노드를 중복되지 않게 전부 방문(visit)하는 것. 

- 트리는 비 선형 구조이기 때문에 선형구조에서와 같이 선후 연결 관계를 알 수 없다. => 특별한 방문 방법인 순회가 필요

- 순회 : 트리의 노드들을 체계적으로 방문하는 것

> 3가지 기본적인 순회 방법 : 전위 순회, 중위 순회, 후위 순회

### 전위 순회(preorder traversal) VLR

- 부모노드 **방문(처리)** 후, **왼쪽 서브트리, 오른쪽 서브트리** 순서로 방문

1. 현재 노드 n을 방문하여 처리

2. 현재 노드 n의 왼쪽 서브트리로 이동

3. 현재 노드 n의 오른쪽 서브트리로 이동

### 중위 순회(inorder traversal) LVR

### 후위 순회(postorder traversal) LRV

> `방문` 보다는 `처리`가 더 정확한 개념. 중위 순회와 후위 순회는 방문했어도 지나치는 경우가 있기 때문. 방문과 처리를 구분하자.

## 이진트리의 표현 - 배열

### 포화이진트리, 완전이진트리에서 사용하는 저장 방법.

- 이진 트리에 각 노드 번호를 부여(루트 번호 1번)

- 레벨 n에 있는 노드에 대하여 왼쪽부터 오른쪽으로 2^n 부터 2^(n + 1) - 1 까지 번호를 차례로 부여

- 마지막 정점 번호까지 인덱스로 하는 배열을 생성(정점 갯수 + 1)

- 배열의 인덱스를 노드 번호로 사용

#### 노드 번호의 성질

- 노드 번호가 i인 노드의 부모 노드 번호 : floor(i/2) ~보다 작은 정수 중 가장 큰 값

    - 파이썬에선 i//2를 사용한다.

- 노드 번호가 i인 노드의 왼쪽 자식 번호 : 2 * i

- 노드 번호가 i인 노드의 오른쪽 자식 노드 번호 : 2 * i + 1

- 레벨 n의 노드 번호 시작 번호는 : 2^n

- 높이가 h인 이진 트리를 위한 배열의 크기는?

    - 레벨 i의 최대 노드 수는 : 2^i

    - 따라서 2^(h + 1) - 1 갯수의 노드가 들어갈 수 있는 배열을 만든다.

    - 노드 수가 제공되지 않은 경우

- 편향이진트리의 경우에도 똑같이. 낭비되는 공간은 크게 신경쓰지 않아도 된다.

### 완전 이진트리나, 포화 이진트리가 아닌 경우

- 2가지 방법(각각 용도가 다름)

- **순회**를 할 때는 부모를 기준으로 자식 번호가 필요

    - 부모를 인덱스로 자식 번호를 저장해야 함

- 조상 또는 루트를 찾을 때는, 부모 번호가 필요

    - 자식을 인덱스로 부모 번호를 저장

### 부모 번호를 인덱스로 자식 번호를 저장

- 1차원 배열 2개를 이용

```
for i : 1 -> N
    read p, c
    if c1[p] == 0
        c1[p] = c
    else
        c2[p] = c
```

### 자식 번호를 인덱스로 부모 번호를 저장

```
for i : 1 -> N
    read p, c
    par[c] = p
```

- 루트 찾기, 조상 찾기

```
c = 5
while (a[c] != 0) 루트인지 확인
    c = a[c]
    anc.append(c) 조상 목록
root = c
```

- 배열을 이용한 이진 트리 표현의 단점

    - 메모리 공간 낭비

    - 문제 풀이에는 문제 없음

## 트리의 표현 - 연결리스트

- 배열을 이용한 이진 트리 표현의 단점을 보완하기 위해 연결리스트를 이용하여 트리를 표현

- 연결 자료구조를 이용한 이진트리의 표현

    - left node, data, right node를 가진 Node class를 선언하여 사용