# Sort 정렬

- 자료를 특정 기준에 의해 작은 값부터 큰 값, 혹은 그 반대의 순서대로 재배열하는 것

- 키(key) : 자료를 정렬하는 기준이 되는 특정 값

> 각 정렬을 함수로 구현해보기

## 정렬의 종류

- 버블 정렬*, 카운팅 정렬*, 선택 정렬*, 퀵 정렬*, 삽입 정렬, 병합 정렬*

## 버블 정렬 Bubble Sort

- 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식

- 시간복잡도 O(n^2)

### 정렬 과정

1. 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동

    - N 인덱스까지 있다면, N-1까지

    - 제일 큰 수가 제일 오른쪽으로 간다.

2. 나머지 구간에 대해서 같은 작업을 반복

## 참고 코드

```python
def bubble_sort(arr, N):
    for i in ragne(N - 1, 0, -1):
        for j in range(0, i):
            if a[j] > a[j + 1]:
                a[j], a[j + 1] = a[j + 1], a[j]
```

## 카운팅 정렬 Counting Sort

- 집합에 각 항목이 몇 개씩 있는지 세는 방식으로 정렬한다.

### 제한 사항

- 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능

    - 발생회수를 기록하기 위해, 정수 항목으로 인덱스되는 카운트들의 배열을 사용하기 때문

    - '0이상 N이하의 정수'라는 조건이 있을 때, 카운팅 정렬 사용

- 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 한다.

### 시간 복잡도

- O(n+k). n은 리스트 길이, k 는 정수의 최대값

    - n과 k 둘 중 큰 값에 영향을 많이 받는다.

### 정렬 과정

- 각 항목들의 발생 횟수를 정수 항목들로 직접 인덱스되는 **카운트 배열**에 저장.

- 카운트 배열의 길이는 100만 정도까지로 제한

- '**이전까지 개수의 합 + 현재 인덱스**'를 구한 새로운 배열을 활용할 것

- data_arr의 **뒤에서부터 값을 확인**한다.

- 확인한 값을 counts의 값 있는 값을 i라 하면, temp[i]에 넣는다.

- **temp가 정렬된 배열**이다.

> 안정정렬이란? 원래 순서 일부가 유지되는 것.

- 원본 배열, 갯수를 센 배열, 임시 배열 

    - 갯수 배열의 길이 잘 만들기

## 참고 코드

```python
# 최댓값이 k인 정수로 이뤄진 입력 배열을 카운팅 소트하는 함수
def counting_sort(A, B, k):    # A: input_arr, B: sorted_arr, k
    C = [0] * (k + 1)   # counting_arr

    for i in range(0, len(A)):
        C[A[i]] += 1
    
    for i in range(1, len(C)):
        C[i] += C[i - 1]

    for i in range(len(B) - 1, -1, -1):
        C[A[i]] -= 1
        B[C[A[i]]] = A[i]
```