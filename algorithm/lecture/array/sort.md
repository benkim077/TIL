# Sort

- 정렬 : 자료를 특정 기준에 의해 작은 값부터 큰 값, 혹은 그 반대의 순서대로 재배열하는 것

- 키 : 자료를 정렬하는 기준이 되는 특정 값

## 정렬의 종류

- 버블 정렬*

- 카운팅 정렬*

- 선택 정렬*

- 퀵 정렬*

- 삽입 정렬

- 변합 정렬*

- *는 코드로 구현할 수 있을 정도로 연습해야 함.

## 버블 정렬

- 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식

- 시간복잡도 O(n**2)

### 정렬 과정

- 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동한다.

- N 인덱스까지 있다면, N-1까지

- 제일 큰 수가 제일 오른쪽으로 감

- 나머지 구간에 대해서 같은 작업을 반복

## 카운팅 정렬

- Counting sort

- 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간( O(n) )에 정렬하는 효율적인 알고리즘

- 제한 사항

    - 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능

    - 발생회수를 기록하기 위해, 정수 항목으로 인덱스되는 카운트들의 배열을 사용하기 때문

    - 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 한다.

- 시간 복잡도

- O(n+k) n은 리스트 길이, k 는 정수의 최대값

    - n과 k 둘 중 큰 값에 영향을 많이 받는다.

### 정렬 과정

- '0이상 N이하의 정수'라는 조건 필요하다.

- Data에서 각 항목들의 발생 회수를 세고, 정수 항목들로 직접 인덱스되는 카운트 배열 counts에 저장.

- counts의 길이는 100만 정도까지로 제한

- '이전까지 개수의 합 + 현재 인덱스'를 구한 새로운 배열을 활용할 것

- data_arr의 뒤에서부터 값을 확인한다.

- 확인한 값을 counts의 값 있는 값을 i라 하면, temp[i]에 넣는다.

- temp가 정렬된 배열이다.

- 안정정렬이란? 원래 순서 일부가 유지되는 것.

- 원본 배열, 갯수를 센 배열, 임시 배열 

    - 갯수 배열의 길이 잘 만들기

