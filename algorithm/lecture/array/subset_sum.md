# 부분집합 합

- 부분집합의 모든 원소를 더한 값이 0이 되는 경우가 있는지 알아내는 문제

##  부분집합 생성하기

- 부분집합을 만드는 방법은 다양하다. 

- 그 중 완전검색 기법으로 부분집합의 합 문제 풀기

- 집합의 원소가 n개일 때, 부분집합의 갯수는 2^n개

- 각 원소가 포함됐는지, 안됐는지 2가지 경우를 n개 원소에 적용한 것

- 각 원소가 포함되었는지를 확인하는 bit를 담는 배열를 만든다.

```python
bit = [0, 0, 0, 0]
for i in range(2):
    bit[0] = i
    for j in range(2):
        bit[1] = j
        for k in range(2):
            bit[2] = k
            for l in range(2):
                bit[3] = l
                print_subset(bit)
```

    - range(2) 범위로 loop를 n번 수행한다.

    - 모든 경우의 bit 배열을 만들었다.

## 비트 연산자

> 비트 연산자를 이용한 다른 방법

> 최소한 눈에는 익혀둘 것

- 비트는 메모리에서 구분할 수 있는 단위

- 주소로 구분되는 최소 단위는 바이트

- &

- |

- <<

- \>\>

### <<

- `1<<n : 2^n` 원소가 n개일 경우의 모든 부분집합의 수

    - `1<<n`는 비트이동 말고 2^n 으로 해석하면 된다. 
    
### &

- &연산. 1하고 and 하면 원래 값, 0하고 and 하면 0이 된다. 

    - 즉 &는 필요한 비트만 남기고 나머지는 0으로 만드는 연산이다. (특정 비트를 0으로 만드는 연산)

- `i & (1<<j)` i의 j번째 비트가 1인지 아닌지 검사

    - `1<<j`는 2^j 또는 j번 비트, 비트 j 라는 의미.

    - 즉 `i & (1<<j)`는 bit j를 제외하고 나머지는 다 0으로 만든다는 의미

    - j bit가 0이면, 결과가 0(전체가 0)

    - j bit가 1이었다면, 0이 아닌 결과

    - (결론) 0이거나, 0이 아니거나를 보고, 확인하고자 하는 자리가 1임을 확인할 수 있다. 

> `i & (1<<j)`는 'i의 j번 비트를 검사'라고 해석하자

### 간결하게 부분집합을 생성하는 방법

> bit 연산을 이용해서 부분집합을 구현해보자.

- arr의 j 원소가 부분집합에 포함되었는지 확인하고 싶다면,

- 6개의 bit를 준비(b5, b4, b3, b2, b1, b0)

- 일단 3개짜리로 생각

- 0부터 7까지(경우의 수 2^3)

- 0~2^-1를 i로 만들자, i의 각 비트 구성이 만들어지니까, i의 j번 비트를 검사해서, j 번 비트가 0이 아니면, `i & (1<<j)`가 참일테니, 그 원소가 포함된 경우 라고 표현할 수 있다.

- 이 코드의 장점, 원소의 갯수가 바뀌어도 코드를 그대로 사용할 수 있다.

```python
arr = [3, 6, 7, 1, 5, 4]
n = len(arr)
for bit in range(1<<n): # 1 << n 을 이용해서 for loop
    for i in range(n): # 원수 수 만큼 비트를 비교
        if bit & (1 << i): # bit의 i 번 비트가 1인 경우 # if (bit >> j) & 1: 만들어주면, 무조건 0, 1 값이 나온다. 
            print(arr[i], end=' ') # j번 원소 출력
    print()
print()
```

### 연습문제

- 10개의 정수를 입력 받아 부분집합의 합이 0이 되는 것이 존재하는지 계산하는 함수를 작성하시오.