# 부분집합 합

- 부분집합의 모든 원소를 더한 값이 0이 되는 경우가 있는지 알아내는 문제

- 부분집합 생성하는 다양한 방법에 대해 알아본다.

## 완전 검색으로 부분집합 만들기

- 집합의 원소가 n개일 때, 부분집합의 갯수는 2^n개

- 각 원소가 포함됐는지, 안됐는지 2가지 경우를 n개 원소에 적용한 것

- 각 원소가 포함되었는지를 확인하는 bit를 담는 배열를 만든다.

- range(2) 범위로 loop를 n번 수행한다.

- 모든 경우의 bit 배열을 만들었다.

```python
# 참고 코드
bit = [0, 0, 0, 0]
for i in range(2):
    bit[0] = i
    for j in range(2):
        bit[1] = j
        for k in range(2):
            bit[2] = k
            for l in range(2):
                bit[3] = l
                print_subset(bit)
```

## 비트 연산자를 이용해서 부분집합 만들기

> bit 연산을 이용해서 부분집합을 구현해보자.
>
> 최소한 눈에는 익혀둘 것

- 비트는 메모리에서 구분할 수 있는 단위

- 주소로 구분되는 최소 단위는 바이트

- 비트 연산

    - `&` bit and 연산

    - `|` bit or 연산

    - `<<` bit left shift 연산

    - `>>` bit right shift 연산

### << 연산의 의미

- `1<<n : 2^n` 원소가 n개일 경우의 모든 부분집합의 수

    - `1<<n`는 비트이동 말고 2^n 으로 해석하면 된다. 
    
### & 연산의 의미

- 1하고 and 하면 원래 값, 0하고 and 하면 0이 된다. 

    - 즉 &는 필요한 비트만 남기고 나머지는 0으로 만드는 연산이다.(특정 비트를 0으로 만드는 연산)

- `i & (1<<j)` i의 j번째 비트가 1인지 아닌지 검사

    - `1<<j`는 2^j 또는 j번 비트, 비트 j 라는 의미.

    - 즉 `i & (1<<j)`는 bit j를 제외하고 나머지는 다 0으로 만든다는 의미

    - j bit가 0이면, 결과가 0(전체가 0)

    - j bit가 1이었다면, 0이 아닌 결과

    - (결론) 0이거나, 0이 아니거나를 보고, 확인하고자 하는 자리가 1임을 확인할 수 있다. 

> `i & (1<<j)`는 'i의 j번 비트를 검사'라고 해석하자

### 코드 설명

> 원소가 3개인 경우를 생각해보자.

- arr의 j 원소가 부분집합에 포함되었는지 확인하고 싶다면,

- 0부터 7까지(0 ~ 2^3), 0~2^-1를 반복문에서 i라 하면

1. i의 각 비트 구성에 대해, i의 j번 비트를 검사해서, 

2. j 번 비트가 0이 아니면, `i & (1<<j)`가 참일테니,

3. 그 원소가 포함된 경우 라고 표현할 수 있다.

```python
arr = [3, 6, 7, 1, 5, 4]
n = len(arr)
for bit in range(1<<n): # 1 << n 을 이용해서 for loop
    for i in range(n): # 원수 수 만큼 비트를 비교
        if bit & (1 << i): # bit의 i 번 비트가 1인 경우 # if (bit >> j) & 1: 만들어주면, 무조건 0, 1 값이 나온다. 
            print(arr[i], end=' ') # j번 원소 출력
    print()
print()
```