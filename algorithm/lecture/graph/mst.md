# 최소 신장 트리

- 그래프에서 최소 비용 문제

    - 모든 정점을 연결하는 간선들의 가중치의 합이 최소가 되는 트리를 구하는 문제 => MST

    - 두 정점 사이의 최소 비용의 경로 또는 비용을 찾는 문제 => 다익스트라

- **신장 트리**(Spanning Tree)

    - n개의 정점으로 이루어진 무방향 그래프에서 n개의 정점과 n-1개의 간선으로 이루어진 트리

- **최소 신장 트리**(Minimum Spanning Tree)

    - 무방향 가중치 그래프에서 **신장 트리를 구성하는 간선들의 가중치의 합이  최소인 신장 트리**

## MST 표현

```python
'''
입력 데이터
6 11
0 1 32
0 2 31
0 5 60
0 6 51
1 2 21
2 4 46
2 6 25
3 4 34
3 5 18
4 5 40
4 6 51
'''

V, E = map(int, input().split())
adj_arr = [[0]*(V + 1) for _ in range(V + 1)]

for _ in range(E):
    u, v, w = map(int, input().split())
    adj_arr[u][v] = w
    adj_arr[v][u] = w
```

- 입력받기

- 인접 행렬 또는 인접 리스트로 입력받을 수 있음.

## Prim 알고리즘

- 하나의 정점에서 연결된 간선들 중에 하나씩 선택하면서 MST를 만들어 가는 방식(대표적인 탐욕 알고리즘)

    1. 임의 정점을 하나 선택해서 시작

    2. 선택한 정점과 인접하는 정점들 중 최소 비용의 간선이 존재하는 정점을 선택

    3. 모든 정점이 선택될 때 까지 1, 2 과정을 반복

- 서로소인 2개의 집합(2 disjoint-sets) 정보를 유지

    - 트리 정점들(tree vertices) - MST를 만들기 위해 선택된 정점들

    - 비트리 정점들(nontree vertices) - 선택되지 않은 정점들

```python
# prim1
```

```python
# prim2
```

## KRUSKAL 알고리즘

- 간선을 하나씩 선택해서 MST를 찾는 알고리즘

    1. 최초, 모든 간선을 가중치에 따라 오름차순으로 정렬

    2. 가중치가 가장 낮은 간선부터 선택하면서 트리를 증가시킴

        - 사이클이 존재하면 다음으로 가중치가 낮은 간선 선택

    3. n - 1개의 간선이 선택될 때까지 2를 반복 

```python
# kruskal
```