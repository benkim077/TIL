# 복잡도 분석

## 알고리즘

- 문제를 해결하는 절차나 방법

## 알고리즘의 효율

- 공간적 효율성 : 연산량 대비 얼마나 적은 메모리 공간을 요하는가

- 시간적 효율성 : 연산량 대비 얼마나 적은 시간을 요하는가

- 복잡도가 높을수록 효율성 저하.

## 시간 복잡도 분석

- 환경적 차이(하드웨어, OS)로 인해 분석이 어렵다.

### 복잡도의 점근적 표기

- 입력 크기에 대한 함수로 표기

- 입력 크기n이 충분히 커질 때의 복잡도를 간단히 표현하기 위해 사용하는 표기법

    - 빅 오, 빅 오메가, 빅 세타

### O(빅 오)-표기

- 빅 오 표기는 복잡도의 점근적 상한(최악의 경우)을 나타낸다.

- `f(n) = 2*(n^2) - 7*n + 4`을 실행시간이 n^2에 비례하는 알고리즘이라고 한다.

- n이 증가함에 따라 O(g(n))이 점근적 상한(n0보다 큰 모든 n에 대해서 항상 f(n)보다 크다는 것)을 보여준다.

### 빅 오메가-표기

- 복잡도의 점근적 하한을 의미

- 최소한 이만한 시간은 걸린다

- n이 증가함에 따라, c*n^2 보다 작을 수 없다. 

### 세타-표기

- 빅오표기와 오메가표기가 같은 경우에 사용

- '이 정도 연산이 항상 발생한다'는 의미

### 자주 사용하는 O-표기

- O(1) : 상수 시간(Constant time)

- O(log n) : 로그(대수) 시간(Logarithmic time)

- O(n) : 선형 시간(Linear time)

- O(n log n) : 로그 선형 시간(log-linear time)

- O(n^2) : 제곱 시간(quadratic time)

- O(n^3) : 세제곱 시간(Cubic time)

- O(2^n) : 지수 시간(Exponential time)

## 왜 효율적인 알고리즘이 필요한가.

- 효율적인 알고리즘은 슈퍼컴퓨터보다 더 큰 가치가 있다.

- 값 비싼 H/W의 기술 개발보다 효율적인 알고리즘 개발이 훨씬 경제적이다.