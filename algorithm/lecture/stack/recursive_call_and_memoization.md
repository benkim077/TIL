# 재귀호출

> 함수 호출(스택)을 통해 재귀를 이해하자.

- 자기 자신을 호출하여 순환 수행되는 것 (ex. 팩토리얼 함수, 피보나치 수열 등)

## 재귀함수의 함수호출 방식

> 함수 호출과 함수 영역, 지역 변수를 생각하면서 이해해보세요.

> 함수는 코드 외부에 저장되있다.

- fn(k)를 호출하면, fn(n)이 호출되고, 그 함수 영역에서 n = k가 된다.

- fct(k)에서 k은 함수 fct 안에서 변수가 된다.

## stack과 재귀 함수 호출

- 재귀호출 기본형 `f(i, N)` 

    - i는 현재 단계, N은 목표

    - 언제 그만 호출할지 정해주는 것

- top이 계속 변한다.

> 재귀를 써야할 때, '호출할 때 마다 메모리의 값이 어떻게 변해야 하는거지?'를 살펴본다.

- 재귀 호출 전, 후로 각 단계별로 해 줄 일들을 적어준다.

## 재귀함수 코드 템플릿

- '재귀함수는 라이브러리다.'라는 마인드로 만들자.

```
# 재귀 함수 설계
    # 1. 종료 조건
    # 2. 하부 호출을 포함한 단위 작업
```

## 재귀로 배열의 원소에 접근

```python
# A 배열을 B배열로 복사
def f(i, N):
    if i == N:
        return
    else:
        B[i] = A[i]
        f(i + 1, N)

N = 3
A = [1, 2, 3]
B = [0] * N
f(0, N)
```

# Memoization

> 재귀함수의 중복 호출 문제

- 피보나치 수열의 Call Tree에서

    - fib(7)을 구할 때, fib(2)가 8번 호출

    - O(2^n)

- 이전에 계산한 값을 메모리에 저장해서, 매번 다시 계산하지 않도록 하여 전체적인 실행속도를 빠르게 하는 기술

> 이전에 계산한 값을 어떻게 넘겨주지? => 테이블(리스트)을 이용

- 동적 계획법의 핵심이 되는 기술 (일단 따로 생각해라?)

## Call Tree

- 콜트리를 그리면 재귀 함수를 만드는 데 도움이 된다.