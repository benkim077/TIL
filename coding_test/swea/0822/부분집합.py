'''
# '가능'한 모든 경우를 구하면 => 정답
# 트리로 표현해보자
    # YES or NO로 표현 가능하다면 이진트리로 접근
    # 일반화
    # 종료 조건 설정
    # 리턴이 없는 함수(전역변수를 이용)

        # 제일 위를 호출하면 나머지는 알아서 진행
        # 함수 가장 위에 종료조건(n에 관련된 것)을 적는다.
        # if n == N:    # 종료 조건
            # 정답 관련 처리
            # return 무조건 먼저 적는다.
        # 하부 함수 호출 (이 부분을 if, else로 나누지 마세요. 모든 경우를 파악하는 것이 백트래킹이다.)
            # YES: dfs(n + 1, ...)   ...는 설계하면서 넣는다.
            # NO: dfs(n + 1, ...)

    # 이 함수가 트리 조각 하나

    # 우리가 사용하는 경우, 사용X
    # 사용하는 경우는 합계에 더하거나 안더하거나
        # dfs(n, sm, ...)로 변경
            # 하부함수 호출도
            # dfs(n + 1, sm + lst[n], ...)   sm에 += 을 사용하지 말자 값이 변해버리니까
            # dfs(n + 1, sm)

# 백트래킹에서 가지치기를 하지 않아도 일단 괜찮다. 나중에 하자.
# 가지치기를 미리 생각하지 말자.
    # 가능한 모든 경우를 한 후에 개선이 필요할 경우에는,
    # 종료 조건 위에서 가지치기한다.
'''

import sys
sys.stdin = open('input.txt')


def dfs(n, sm):
    global ans

    # 가지치기는 제일 위에 위치시킨다. 미리 하지 말고 제일 마지막 순서로
    if sm > K:  # 이미 K값 초과해서 답을 찾을 가능성이 없는 경우
        return

    # 종료 조건
    if n == N:
        if sm == K: # 필요한게 있으면 여기에
            ans += 1
        return

    # dfs(n + 1) 호출 (하부함수)
    dfs(n + 1, sm + lst[n])         # 사용하는 경우
    dfs(n + 1, sm)                  # 사용하지 않는 경우


T = int(input())
for tc in range(1, T + 1):
    N, K = map(int, input().split())
    lst = list(map(int, input().split()))

    ans = 0

    dfs(0, 0)

    print(f'#{tc} {ans}')